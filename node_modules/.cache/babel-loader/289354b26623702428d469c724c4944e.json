{"ast":null,"code":"import { put, all, call, select, takeEvery } from 'redux-saga/effects';\nimport { types, getNerData, getRelationData } from '../reducers/editstate';\nimport axios from 'axios';\nimport { initialLayout } from '../utils/layout';\nimport { initialOverviewLayout } from '../utils/overviewLayout.js'; // Posts the updated relation data to the backend and returns the updated network data.\n\nconst apiPostNetwork = data => {\n  const formData = new FormData();\n  formData.append('relationData', JSON.stringify(data));\n  return axios.post('http://localhost:5000/updateNetwork', formData);\n}; // Dispatches the action UPDATED_NETWORK_DATA to update the redux store with the new network data based on the file that was changed.\n\n\nfunction* updateNetworkHelper(_ref) {\n  let {\n    data,\n    currentFileName\n  } = _ref;\n  const res = yield call(apiPostNetwork, data);\n  const networkData = res.data;\n  yield put({\n    type: types.UPDATED_NETWORK_DATA,\n    payload: networkData,\n    currentFileName: currentFileName\n  });\n} // Dispatches the action UPLOADED_CORPUS_DATA to update the redux store with the new corpus data.\n\n\nfunction* setCorpusData(_ref2) {\n  let {\n    data\n  } = _ref2;\n  yield put({\n    type: types.UPLOADED_CORPUS_DATA,\n    payload: data\n  });\n} // Dispatches the action SET_FILENAMES and SET_LAYOUT based on the object keys of the corpus data.\n\n\nfunction* setFileNames(_ref3) {\n  let {\n    data\n  } = _ref3;\n  const fileNames = Object.keys(data);\n  yield put({\n    type: types.SET_FILENAMES,\n    payload: fileNames\n  });\n  var layouts = {};\n\n  if (fileNames.length > 1) {\n    fileNames.filter(e => e !== 'Overview').forEach(e => layouts[e] = initialLayout);\n    layouts['Overview'] = initialOverviewLayout;\n  } else {\n    layouts[fileNames[0]] = initialLayout;\n  }\n\n  yield put({\n    type: types.SET_LAYOUT,\n    payload: layouts\n  });\n} // Posts the uploaded files to the backend and returns the output.\n\n\nconst apiPost = payload => {\n  const formData = new FormData();\n  console.log(\"payload: \", payload);\n  var fileNames = [];\n\n  for (var i = 0; i < payload.files.length; i++) {\n    formData.append('file'.concat(i.toString()), payload.files[i]);\n    fileNames.push(payload.files[i].name);\n  }\n\n  fileNames = JSON.stringify(fileNames);\n  formData.append('fileNames', fileNames);\n  formData.append('length', payload.files.length);\n  console.log(\"payload files \", payload.files);\n  var configFile = JSON.stringify(payload.config);\n  formData.append('config', configFile);\n  console.log(\"config: \", configFile); // inspect formData\n\n  for (var pair of formData.entries()) {\n    console.log(pair[0] + ', ' + pair[1]);\n  }\n\n  return axios.post('http://uploadfile-sme-project.apps.kw.projectinnovate.sg/uploadFile', formData);\n}; // Posts the JSON document to the backend and returns the output.\n\n\nconst apiPostJson = payload => {\n  const formData = new FormData();\n  formData.append('existingFile', payload); // 'http://loadexistingfile-alice.apps.8d5714affbde4fa6828a.southeastasia.azmosa.io/loadExistingFile'\n\n  return axios.post('http://loadexistingfile-sme-project.apps.kw.projectinnovate.sg/loadExistingFile', formData);\n}; // Posts the ObjectID of the document and returns the output from the MongoDB entry corresponding\n// to that ObjectID.\n\n\nconst apiPostDb = payload => {\n  // 'http://loaddbfile-alice.apps.8d5714affbde4fa6828a.southeastasia.azmosa.io/loadDbFile'\n  return axios.post('http://localhost:5000/loadDbFile', {\n    ID: payload\n  });\n}; // Posts the webscape request to the backend and returns the output.\n\n\nconst apiScrape = payload => {\n  /*\n  Have to convert the dictionary to a compatible object form for Flask to receive properly\n  however, an array will still be received as a string by Flask so\n  manipulate the data form at the scraper side instead\n  see here for more info https://stackoverflow.com/questions/54892531/axios-data-coming-up-as-immutablemultidict-when-sent-to-flask-post-route-bu\n  */\n  const params = new URLSearchParams();\n  const keys = Object.keys(payload);\n\n  for (let key of keys) {\n    params.append(key, payload[key]);\n  } //return axios.post('http://localhost:5000/scrape', params);\n\n\n  return axios.post('http://scrape-sme-project.apps.kw.projectinnovate.sg/scrape', params);\n};\n\nvar download_url = null;\nexport function get_download_url() {\n  return download_url;\n} // Uploads the data to the backend to call the respective webscraper API in the backend\n// dispatches the action SCRAPING_SUCCESS or SCRAPING_FAILURE depending\n// on the status of the upload.\n\nexport function* scrapeData(_ref4) {\n  let {\n    payload\n  } = _ref4;\n\n  try {\n    let res;\n    console.log(payload);\n    res = yield call(apiScrape, payload);\n    console.log('response', res);\n    download_url = res.data;\n    yield put({\n      type: types.SCRAPING_SUCCESS\n    });\n  } catch (error) {\n    yield put({\n      type: types.SCRAPING_FAILURE\n    });\n    console.log('Error while scraping', error);\n  }\n} // Uploads the data to the backend based on the input type and\n// dispatches the action UPLOAD_SUCCESS or UPLOAD_FAILURE depending\n// on the status of the upload.\n// If the document uploaded is an existing one (JSON or MongoDB ObjectID),\n// the function dispatches the action SET_EXISTING_DOCUMENT.\n\nexport function* uploadData(_ref5) {\n  let {\n    payload\n  } = _ref5;\n\n  try {\n    let res;\n\n    if (payload.existing) {\n      if (payload.docId) {\n        res = yield call(apiPostDb, payload.docId);\n        console.log(payload);\n        console.log(res);\n      } else {\n        res = yield call(apiPostJson, payload.files);\n      }\n\n      console.log(payload);\n      console.log(res);\n      const existingData = res.data; // Remove bugs related to network graph when loading existing file\n\n      existingData.fileNames.forEach(document => {\n        console.log(existingData);\n        console.log(existingData.corpusData[document]);\n\n        if (existingData.corpusData[document].network.links.length > 0) {\n          if (existingData.corpusData[document].network.links[0].source.id) {\n            existingData.corpusData[document].network.links.forEach(link => {\n              link.source = link.source.id;\n              link.target = link.target.id;\n              delete link.__indexColor;\n              delete link.__controlPoints;\n              delete link.__photons;\n              delete link.index;\n            });\n            existingData.corpusData[document].network.nodes.forEach(node => {\n              delete node.index;\n              delete node.x;\n              delete node.y;\n              delete node.vx;\n              delete node.vy;\n              delete node.__indexColor;\n            });\n          }\n        }\n      });\n      yield put({\n        type: types.SET_EXISTING_DOCUMENT,\n        payload: existingData\n      });\n    } else {\n      console.log(\"apipost payload\", payload);\n      res = yield call(apiPost, payload);\n      const newData = res.data;\n\n      if (Object.keys(newData).length === 0) {\n        throw new Error('Document could not be processed');\n      } // Remove bugs related to network graph when generating new data\n\n\n      Object.keys(newData.corpusData).forEach(document => {\n        console.log(newData);\n        console.log(newData.corpusData[document]);\n\n        if (newData.corpusData[document].network.links.length > 0) {\n          if (newData.corpusData[document].network.links[0].source.id) {\n            newData.corpusData[document].network.links.forEach(link => {\n              link.source = link.source.id;\n              link.target = link.target.id;\n              delete link.__indexColor;\n              delete link.__controlPoints;\n              delete link.__photons;\n              delete link.index;\n            });\n            newData.corpusData[document].network.nodes.forEach(node => {\n              delete node.index;\n              delete node.x;\n              delete node.y;\n              delete node.vx;\n              delete node.vy;\n              delete node.__indexColor;\n            });\n          }\n        }\n      });\n      const args = {\n        data: newData.corpusData\n      };\n      yield all([call(setCorpusData, args), call(setFileNames, args)]);\n    }\n\n    yield put({\n      type: types.UPLOAD_SUCCESS\n    });\n  } catch (error) {\n    yield put({\n      type: types.UPLOAD_FAILURE\n    });\n    console.log('ERROR', error);\n  }\n} // Dispatches the action UPDATED_NER_DATA to update the redux store with the new NER data based on the file that was changed.\n// // Updates the relation and network data based on the new changes.\n\nfunction* updateNer(_ref6) {\n  let {\n    payload\n  } = _ref6;\n  const {\n    newNer,\n    nerToRelation,\n    currentFileName\n  } = payload;\n  const currentNerData = yield select(getNerData, [currentFileName]);\n  const text = currentNerData.text;\n  const currentRelationData = yield select(getRelationData, currentFileName);\n  var newRelationData;\n\n  if (nerToRelation[3] === 'DELETE') {\n    newRelationData = currentRelationData.filter(e => {\n      return (e.e1 !== nerToRelation[0] || e.e1_id !== nerToRelation[1]) && (e.e2 !== nerToRelation[0] || e.e2_id !== nerToRelation[1]);\n    });\n  } else {\n    newRelationData = currentRelationData.map(e => {\n      if (e.e1 === nerToRelation[0] && e.e1_id === nerToRelation[1]) {\n        e.e1_label = nerToRelation[2];\n      } else if (e.e2 === nerToRelation[0] && e.e2_id === nerToRelation[1]) {\n        e.e2_label = nerToRelation[2];\n      }\n\n      return e;\n    });\n  }\n\n  yield put({\n    type: types.UPDATED_NER_DATA,\n    payload: {\n      text: text,\n      ents: newNer\n    },\n    currentFileName: currentFileName\n  });\n  const args = {\n    data: newRelationData,\n    currentFileName: currentFileName\n  };\n  yield all([call(updateRelationHelper, args), call(updateNetworkHelper, args)]);\n} // Dispatches the action UPDATED_RELATION_DATA to update the redux store with the new relation data based on the file that was changed.\n\n\nfunction* updateRelationHelper(_ref7) {\n  let {\n    data,\n    currentFileName\n  } = _ref7;\n  yield put({\n    type: types.UPDATED_RELATION_DATA,\n    payload: data,\n    currentFileName: currentFileName\n  });\n} // Updates the relation and network data based on the new changes.\n\n\nfunction* updateRelation(_ref8) {\n  let {\n    payload\n  } = _ref8;\n  const {\n    newRelation,\n    currentFileName\n  } = payload;\n  const args = {\n    data: newRelation,\n    currentFileName: currentFileName\n  };\n  yield all([call(updateRelationHelper, args), call(updateNetworkHelper, args)]);\n}\n\nexport default [takeEvery(types.UPLOADING_DATA, uploadData), takeEvery(types.SCRAPING_DATA, scrapeData), takeEvery(types.UPDATING_NER_DATA, updateNer), takeEvery(types.UPDATING_RELATION_DATA, updateRelation)];","map":{"version":3,"names":["put","all","call","select","takeEvery","types","getNerData","getRelationData","axios","initialLayout","initialOverviewLayout","apiPostNetwork","data","formData","FormData","append","JSON","stringify","post","updateNetworkHelper","currentFileName","res","networkData","type","UPDATED_NETWORK_DATA","payload","setCorpusData","UPLOADED_CORPUS_DATA","setFileNames","fileNames","Object","keys","SET_FILENAMES","layouts","length","filter","e","forEach","SET_LAYOUT","apiPost","console","log","i","files","concat","toString","push","name","configFile","config","pair","entries","apiPostJson","apiPostDb","ID","apiScrape","params","URLSearchParams","key","download_url","get_download_url","scrapeData","SCRAPING_SUCCESS","error","SCRAPING_FAILURE","uploadData","existing","docId","existingData","document","corpusData","network","links","source","id","link","target","__indexColor","__controlPoints","__photons","index","nodes","node","x","y","vx","vy","SET_EXISTING_DOCUMENT","newData","Error","args","UPLOAD_SUCCESS","UPLOAD_FAILURE","updateNer","newNer","nerToRelation","currentNerData","text","currentRelationData","newRelationData","e1","e1_id","e2","e2_id","map","e1_label","e2_label","UPDATED_NER_DATA","ents","updateRelationHelper","UPDATED_RELATION_DATA","updateRelation","newRelation","UPLOADING_DATA","SCRAPING_DATA","UPDATING_NER_DATA","UPDATING_RELATION_DATA"],"sources":["C:/1.Regine/PDA-APP/frontend/src/sagas/editstate.js"],"sourcesContent":["import { put, all, call, select, takeEvery } from 'redux-saga/effects';\nimport {\n  types,\n  getNerData,\n  getRelationData,\n} from '../reducers/editstate';\nimport axios from 'axios';\nimport { initialLayout } from '../utils/layout';\nimport { initialOverviewLayout } from '../utils/overviewLayout.js';\n\n// Posts the updated relation data to the backend and returns the updated network data.\nconst apiPostNetwork = (data) => {\n  const formData = new FormData();\n  formData.append('relationData', JSON.stringify(data));\n  return axios.post('http://localhost:5000/updateNetwork', formData);\n};\n\n// Dispatches the action UPDATED_NETWORK_DATA to update the redux store with the new network data based on the file that was changed.\nfunction* updateNetworkHelper({ data, currentFileName }) {\n  const res = yield call(apiPostNetwork, data);\n  const networkData = res.data;\n  yield put({\n    type: types.UPDATED_NETWORK_DATA,\n    payload: networkData,\n    currentFileName: currentFileName,\n  });\n}\n\n\n// Dispatches the action UPLOADED_CORPUS_DATA to update the redux store with the new corpus data.\nfunction* setCorpusData({ data }) {\n  yield put({\n    type: types.UPLOADED_CORPUS_DATA,\n    payload: data,\n  });\n}\n\n// Dispatches the action SET_FILENAMES and SET_LAYOUT based on the object keys of the corpus data.\nfunction* setFileNames({ data }) {\n  const fileNames = Object.keys(data);\n  yield put({\n    type: types.SET_FILENAMES,\n    payload: fileNames,\n  });\n  var layouts = {};\n  if (fileNames.length > 1) {\n    fileNames\n      .filter((e) => e !== 'Overview')\n      .forEach((e) => (layouts[e] = initialLayout));\n    layouts['Overview'] = initialOverviewLayout;\n  } else {\n    layouts[fileNames[0]] = initialLayout;\n  }\n  yield put({\n    type: types.SET_LAYOUT,\n    payload: layouts,\n  });\n}\n\n// Posts the uploaded files to the backend and returns the output.\nconst apiPost = (payload) => {\n  const formData = new FormData();\n  console.log(\"payload: \", payload)\n  var fileNames = [];\n  for (var i = 0; i < payload.files.length; i++) {\n    formData.append('file'.concat(i.toString()), payload.files[i]);\n    fileNames.push(payload.files[i].name);\n  }\n  fileNames = JSON.stringify(fileNames);\n  formData.append('fileNames', fileNames);\n  formData.append('length', payload.files.length);\n\n  console.log(\"payload files \", payload.files)\n  \n  var configFile = JSON.stringify(payload.config)\n  formData.append('config', configFile);\n\n  console.log(\"config: \", configFile)\n\n  // inspect formData\n  for (var pair of formData.entries()) {\n      console.log(pair[0]+ ', ' + pair[1]); \n  }\n\n  return axios.post('http://uploadfile-sme-project.apps.kw.projectinnovate.sg/uploadFile', formData);\n};\n\n// Posts the JSON document to the backend and returns the output.\nconst apiPostJson = (payload) => {\n  const formData = new FormData();\n  formData.append('existingFile', payload);\n  // 'http://loadexistingfile-alice.apps.8d5714affbde4fa6828a.southeastasia.azmosa.io/loadExistingFile'\n  return axios.post('http://loadexistingfile-sme-project.apps.kw.projectinnovate.sg/loadExistingFile', formData);\n};\n\n// Posts the ObjectID of the document and returns the output from the MongoDB entry corresponding\n// to that ObjectID.\nconst apiPostDb = (payload) => {\n  // 'http://loaddbfile-alice.apps.8d5714affbde4fa6828a.southeastasia.azmosa.io/loadDbFile'\n  return axios.post('http://localhost:5000/loadDbFile', {ID: payload});\n}\n\n\n// Posts the webscape request to the backend and returns the output.\nconst apiScrape = (payload) => {\n  /*\n  Have to convert the dictionary to a compatible object form for Flask to receive properly\n  however, an array will still be received as a string by Flask so\n  manipulate the data form at the scraper side instead\n  see here for more info https://stackoverflow.com/questions/54892531/axios-data-coming-up-as-immutablemultidict-when-sent-to-flask-post-route-bu\n  */\n  \n  const params = new URLSearchParams();\n  const keys = Object.keys(payload);\n  for (let key of keys) {\n      params.append(key, payload[key]);\n  }\n\n  //return axios.post('http://localhost:5000/scrape', params);\n  return axios.post('http://scrape-sme-project.apps.kw.projectinnovate.sg/scrape', params);\n  };\n\n\nvar download_url = null;\n\nexport function get_download_url() {\n  return download_url;\n}\n\n// Uploads the data to the backend to call the respective webscraper API in the backend\n// dispatches the action SCRAPING_SUCCESS or SCRAPING_FAILURE depending\n// on the status of the upload.\nexport function* scrapeData({ payload }) {\n  try {\n    let res;\n    console.log(payload);\n    res = yield call(apiScrape, payload);\n\n    console.log('response', res);\n    download_url = res.data;\n\n    yield put({\n      type: types.SCRAPING_SUCCESS,\n    });\n  } catch (error) {\n    yield put({\n      type: types.SCRAPING_FAILURE,\n    });\n    console.log('Error while scraping', error);\n  }\n}\n \n\n// Uploads the data to the backend based on the input type and\n// dispatches the action UPLOAD_SUCCESS or UPLOAD_FAILURE depending\n// on the status of the upload.\n// If the document uploaded is an existing one (JSON or MongoDB ObjectID),\n// the function dispatches the action SET_EXISTING_DOCUMENT.\nexport function* uploadData({ payload }) {\n  try {\n    let res;\n    if (payload.existing) {\n      if (payload.docId) {\n        res = yield call(apiPostDb, payload.docId);\n        console.log(payload)\n        console.log(res)\n      } else {\n        res = yield call(apiPostJson, payload.files);\n      }\n      console.log(payload)\n      console.log(res)\n      const existingData = res.data;\n\n      // Remove bugs related to network graph when loading existing file\n      existingData.fileNames.forEach((document) => {\n        console.log(existingData);\n        console.log(existingData.corpusData[document]);\n        if (existingData.corpusData[document].network.links.length > 0) {\n          if (existingData.corpusData[document].network.links[0].source.id) {\n            existingData.corpusData[document].network.links.forEach((link) => {\n              link.source = link.source.id;\n              link.target = link.target.id;\n              delete link.__indexColor;\n              delete link.__controlPoints;\n              delete link.__photons;\n              delete link.index;\n            });\n\n            existingData.corpusData[document].network.nodes.forEach((node) => {\n              delete node.index;\n              delete node.x;\n              delete node.y;\n              delete node.vx;\n              delete node.vy;\n              delete node.__indexColor;\n            });\n          }\n        }\n      });\n\n      yield put({\n        type: types.SET_EXISTING_DOCUMENT,\n        payload: existingData,\n      });\n    } else {\n      console.log(\"apipost payload\", payload);\n      res = yield call(apiPost, payload);\n      const newData = res.data;\n      if (Object.keys(newData).length === 0) {\n        throw new Error('Document could not be processed');\n      }\n\n      // Remove bugs related to network graph when generating new data\n      Object.keys(newData.corpusData).forEach((document) => {\n        console.log(newData);\n        console.log(newData.corpusData[document]);\n        if (newData.corpusData[document].network.links.length > 0) {\n          if (newData.corpusData[document].network.links[0].source.id) {\n            newData.corpusData[document].network.links.forEach((link) => {\n              link.source = link.source.id;\n              link.target = link.target.id;\n              delete link.__indexColor;\n              delete link.__controlPoints;\n              delete link.__photons;\n              delete link.index;\n            });\n\n            newData.corpusData[document].network.nodes.forEach((node) => {\n              delete node.index;\n              delete node.x;\n              delete node.y;\n              delete node.vx;\n              delete node.vy;\n              delete node.__indexColor;\n            });\n          }\n        }\n      });\n      const args = { data: newData.corpusData };\n      yield all([call(setCorpusData, args), call(setFileNames, args)]);\n    }\n    yield put({\n      type: types.UPLOAD_SUCCESS,\n    });\n  } catch (error) {\n    yield put({\n      type: types.UPLOAD_FAILURE,\n    });\n    console.log('ERROR', error);\n  }\n}\n\n// Dispatches the action UPDATED_NER_DATA to update the redux store with the new NER data based on the file that was changed.\n// // Updates the relation and network data based on the new changes.\nfunction* updateNer({ payload }) {\n  const { newNer, nerToRelation, currentFileName } = payload;\n  const currentNerData = yield select(getNerData, [currentFileName]);\n  const text = currentNerData.text;\n  const currentRelationData = yield select(getRelationData, currentFileName);\n  var newRelationData;\n  if (nerToRelation[3] === 'DELETE') {\n    newRelationData = currentRelationData.filter((e) => {\n      return (\n        (e.e1 !== nerToRelation[0] || e.e1_id !== nerToRelation[1]) &&\n        (e.e2 !== nerToRelation[0] || e.e2_id !== nerToRelation[1])\n      );\n    });\n  } else {\n    newRelationData = currentRelationData.map((e) => {\n      if (e.e1 === nerToRelation[0] && e.e1_id === nerToRelation[1]) {\n        e.e1_label = nerToRelation[2];\n      } else if (e.e2 === nerToRelation[0] && e.e2_id === nerToRelation[1]) {\n        e.e2_label = nerToRelation[2];\n      }\n      return e;\n    });\n  }\n\n  yield put({\n    type: types.UPDATED_NER_DATA,\n    payload: {\n      text: text,\n      ents: newNer,\n    },\n    currentFileName: currentFileName,\n  });\n  const args = { data: newRelationData, currentFileName: currentFileName };\n  yield all([\n    call(updateRelationHelper, args),\n    call(updateNetworkHelper, args),\n  ]);\n}\n\n// Dispatches the action UPDATED_RELATION_DATA to update the redux store with the new relation data based on the file that was changed.\nfunction* updateRelationHelper({ data, currentFileName }) {\n  yield put({\n    type: types.UPDATED_RELATION_DATA,\n    payload: data,\n    currentFileName: currentFileName,\n  });\n}\n\n// Updates the relation and network data based on the new changes.\nfunction* updateRelation({ payload }) {\n  const { newRelation, currentFileName } = payload;\n  const args = { data: newRelation, currentFileName: currentFileName };\n  yield all([\n    call(updateRelationHelper, args),\n    call(updateNetworkHelper, args),\n  ]);\n}\n\nexport default [\n  takeEvery(types.UPLOADING_DATA, uploadData),\n  takeEvery(types.SCRAPING_DATA, scrapeData),\n  takeEvery(types.UPDATING_NER_DATA, updateNer),\n  takeEvery(types.UPDATING_RELATION_DATA, updateRelation),\n];\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}